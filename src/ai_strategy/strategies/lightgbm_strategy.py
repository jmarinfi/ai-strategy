"""LightGBM-based trading strategy implementation."""

import asyncio
from pathlib import Path

import numpy as np
import pandas as pd

from src.ai_strategy.data import BaseStreamer, CCXTFetcher
from src.ai_strategy.models import Candle, Signal, SignalType
from src.ai_strategy.models.sklearn import LightGBMModel
from src.ai_strategy.strategies.base import BaseStrategy


def parse_timeframe_to_minutes(timeframe: str) -> int:
    """Convert timeframe string (e.g. '15m', '1h', '4h', '1d') to minutes."""
    unit = timeframe[-1]
    value = int(timeframe[:-1])

    if unit == "m":
        return value
    elif unit == "h":
        return value * 60
    elif unit == "d":
        return value * 24 * 60
    elif unit == "w":
        return value * 24 * 60 * 7
    else:
        raise ValueError(f"Unsupported timeframe unit: {unit}")


def add_technical_indicators(df: pd.DataFrame) -> pd.DataFrame:
    """Add technical indicators (RSI, MACD, BB, ATR, Volume, Momentum) to the DataFrame.

    Args:
        df: DataFrame with OHLCV data.

    Returns:
        DataFrame with technical indicators added.
    """
    # Ensure sorted by timestamp
    df = df.sort_values("timestamp").reset_index(drop=True)

    # Convert numbers to numeric just in case
    cols = ["open", "high", "low", "close", "volume"]
    for col in cols:
        df[col] = pd.to_numeric(df[col], errors="coerce")

    # ===== RSI =====
    for period in [14, 21]:
        delta = df["close"].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss.replace(0, 1e-10)
        df[f"rsi_{period}"] = 100 - (100 / (1 + rs))

    # ===== MACD =====
    ema_12 = df["close"].ewm(span=12, adjust=False).mean()
    ema_26 = df["close"].ewm(span=26, adjust=False).mean()
    df["macd"] = ema_12 - ema_26
    df["macd_signal"] = df["macd"].ewm(span=9, adjust=False).mean()
    df["macd_hist"] = df["macd"] - df["macd_signal"]

    # ===== Bollinger Bands =====
    sma_20 = df["close"].rolling(window=20).mean()
    std_20 = df["close"].rolling(window=20).std()
    df["bb_upper"] = sma_20 + (2 * std_20)
    df["bb_lower"] = sma_20 - (2 * std_20)
    df["bb_position"] = (df["close"] - df["bb_lower"]) / (
        df["bb_upper"] - df["bb_lower"]
    )

    # ===== ATR =====
    high_low = df["high"] - df["low"]
    high_close = np.abs(df["high"] - df["close"].shift())
    low_close = np.abs(df["low"] - df["close"].shift())
    true_range = pd.concat([high_low, high_close, low_close], axis=1).max(axis=1)
    df["atr"] = true_range.rolling(window=14).mean()

    # ===== Volume =====
    df["volume_sma"] = df["volume"].rolling(window=20).mean()
    df["volume_ratio"] = df["volume"] / df["volume_sma"]

    # ===== Momentum =====
    df["momentum_5"] = df["close"].pct_change(periods=5)
    df["momentum_10"] = df["close"].pct_change(periods=10)

    # Clean up NaN values generated by rolling windows
    df.replace([np.inf, -np.inf], np.nan, inplace=True)
    df.dropna(inplace=True)

    return df


class LightGBMStrategy(BaseStrategy):
    """Trading strategy using LightGBM model for predictions.

    This strategy processes candlestick data, calculates technical indicators,
    makes predictions using a trained LightGBM model, and generates trading signals.
    """

    def __init__(
        self,
        symbols: list[str],
        streamer: BaseStreamer,
        webhook_url: str,
        bot_uuid: str,
        model_path: str | Path,
        timeframe: str,
        exchange: str = "bitget",
        prob_threshold: float = 0.52,
        historical_candles: int = 60,
    ) -> None:
        """Initialize the LightGBM strategy.

        Args:
            symbols: List of trading pair symbols.
            streamer: Data streamer for real-time market data.
            webhook_url: URL for sending webhooks.
            bot_uuid: UUID of the trading bot.
            model_path: Path to the trained LightGBM model file.
            timeframe: Candle timeframe (e.g., '5m', '1h').
            exchange: Exchange name (default: 'bitget').
            prob_threshold: Probability threshold for generating signals (default: 0.52).
            historical_candles: Number of historical candles to fetch for indicators (default: 60).
        """
        super().__init__(symbols, streamer, webhook_url, bot_uuid)

        self.timeframe = timeframe
        self.exchange = exchange
        self.prob_threshold = prob_threshold
        self.historical_candles = historical_candles

        # Load the model using LightGBMModel wrapper
        self.model = LightGBMModel(model_path)

        # Track last processed candle
        self._last_candle_timestamp: int | None = None
        self._previous_candle: Candle | None = None

    async def on_candle(self, candle: Candle) -> None:
        """Process a new candlestick from the market.

        Detects when a candle is complete, fetches historical data,
        calculates indicators, makes predictions, and generates signals.

        Args:
            candle: Current market candle data (OHLCV).
        """
        current_timestamp = candle.timestamp

        # Detect new candle (timestamp changed)
        if current_timestamp != self._last_candle_timestamp:
            # Process the PREVIOUS candle (which is now complete)
            if self._previous_candle is not None:
                await self._process_complete_candle(self._previous_candle)

            # Update tracking
            self._last_candle_timestamp = current_timestamp

        # Always update previous_candle with the latest data
        self._previous_candle = candle

    async def _process_complete_candle(self, candle: Candle) -> None:
        """Process a complete candle and make trading decisions.

        Args:
            candle: Complete candle to process.
        """
        try:
            # 1. Fetch historical candles for indicators
            historical_df = await self._fetch_historical_data(candle)

            if historical_df is None or len(historical_df) < 50:
                return  # Not enough data

            # 2. Calculate technical indicators
            df_with_indicators = add_technical_indicators(historical_df)

            if len(df_with_indicators) == 0:
                return  # No data after indicator calculation

            # 3. Get latest features and make prediction
            latest_features = df_with_indicators.iloc[-1]
            prediction = self.model.predict(latest_features)

            # 4. Generate signal based on prediction
            signal = self.generate_signal(candle, prediction)

            # 5. Execute signal if actionable
            if signal.is_actionable:
                await self._execute_signal(signal)

        except Exception as e:
            # Log error but don't crash the strategy
            print(f"Error processing candle: {e}")

    async def _fetch_historical_data(self, candle: Candle) -> pd.DataFrame | None:
        """Fetch historical candles needed for indicator calculation.

        Args:
            candle: Reference candle for end timestamp.

        Returns:
            DataFrame with historical OHLCV data, or None if fetch failed.
        """
        try:
            fetcher = CCXTFetcher(self.exchange, sandbox=False)

            end_ts = candle.timestamp
            start_ts = end_ts - (
                60
                * 1000
                * parse_timeframe_to_minutes(self.timeframe)
                * self.historical_candles
            )

            historical_df = await fetcher.fetch_ohlcv_range(
                candle.symbol, self.timeframe, start_ts, end_ts
            )
            await fetcher.close()

            return historical_df

        except Exception:
            return None


    def generate_signal(
        self, candle: Candle, prediction: dict[str, float] | None = None
    ) -> Signal:
        """Generate a trading signal based on the candle and prediction.

        Args:
            candle: Current market candle data (OHLCV).
            prediction: Model prediction with 'prob_down' and 'prob_up'.

        Returns:
            Signal indicating whether to buy, sell, or hold.
        """
        if prediction is None:
            return Signal(
                signal_type=SignalType.HOLD,
                symbol=candle.symbol,
                price=candle.close,
                timestamp=candle.datetime_,
            )

        prob_up = prediction["prob_up"]
        prob_down = prediction["prob_down"]

        # Determine signal based on threshold
        if prob_up > self.prob_threshold:
            return Signal(
                signal_type=SignalType.BUY,
                symbol=candle.symbol,
                price=candle.close,
                confidence=prob_up,
                model_prediction=prob_up,
                reason=f"High probability of upward movement ({prob_up:.2%})",
            )
        elif prob_down > self.prob_threshold:
            return Signal(
                signal_type=SignalType.SELL,
                symbol=candle.symbol,
                price=candle.close,
                confidence=prob_down,
                model_prediction=prob_down,
                reason=f"High probability of downward movement ({prob_down:.2%})",
            )
        else:
            return Signal(
                signal_type=SignalType.HOLD,
                symbol=candle.symbol,
                price=candle.close,
                confidence=max(prob_up, prob_down),
                model_prediction=max(prob_up, prob_down),
                reason=f"Probabilities below threshold (UP: {prob_up:.2%}, DOWN: {prob_down:.2%})",
            )

    async def _execute_signal(self, signal: Signal) -> None:
        """Execute a trading signal by sending webhooks.

        Args:
            signal: Signal to execute.
        """
        if signal.signal_type == SignalType.BUY:
            await self.open_position(signal.symbol)
        elif signal.signal_type == SignalType.SELL:
            await self.close_position(signal.symbol)
        # HOLD does nothing
